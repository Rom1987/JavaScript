<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>12.Циклы while и for</title>
</head>
<body>
    <script>
    // Циклы while и for
    // Цикл «while»
    // Цикл while имеет следующий синтаксис:
    //  while (condition) {
    //   // код
    //   // также называемый "телом цикла"
    // }
    // let i = 0;
    // while (i < 3) { // выводит 0, затем 1, затем 2
    //   alert( i );
    //   i++;
    // }
    // Одно выполнение тела цикла по-научному называется итерация. Цикл в примере выше совершает три итерации.
    // Например, while (i) – более краткий вариант while (i != 0):
    // let i = 3;
    // while (i) { // когда i будет равно 0, условие станет ложным, и цикл остановится
    //   alert( i );
    //   i--;
    // }
    // Фигурные скобки не требуются для тела цикла из одной строки
    // Если тело цикла состоит лишь из одной инструкции, мы можем опустить фигурные скобки {…}:
    // let i = 3;
    // while (i) alert(i--);

    // Цикл «do…while»
    // Проверку условия можно разместить под телом цикла, используя специальный синтаксис do..while:
    // do {
    //   // тело цикла
    // } while (condition);
    // Цикл сначала выполнит тело, а затем проверит условие condition, и пока его значение равно true, он будет выполняться снова и снова.
    // Например:
    // let i = 0;
    // do {
    //   alert( i );
    //   i++;
    // } while (i < 3);

    // Цикл «for»
    // for (начало; условие; шаг) {
    // // ... тело цикла ...
    // }
    // for (let i = 0; i < 3; i++) { // выведет 0, затем 1, затем 2
    // alert(i);
    // }
    // for (let i = 0; i < 3; i++) {
    // alert(i); // 0, 1, 2
    // }
    // alert(i); // ошибка, нет такой переменной
    // Вместо объявления новой переменной мы можем использовать уже существующую:
    // let i = 0;
    // for (i = 0; i < 3; i++) { // используем существующую переменную
    //   alert(i); // 0, 1, 2
    // }
    // alert(i); // 3, переменная доступна, т.к. была объявлена снаружи цикла

    // Пропуск частей «for»
    // Любая часть for может быть пропущена.
    // Для примера, мы можем пропустить начало если нам ничего не нужно делать перед стартом цикла.
    // Вот так:
    // let i = 0; // мы уже имеем объявленную i с присвоенным значением
    // for (; i < 3; i++) { // нет необходимости в "начале"
    //   alert( i ); // 0, 1, 2
    // }
    // Можно убрать и шаг:
    // let i = 0;
    // for (; i < 3;) {
    //   alert( i++ );
    // }
    // Это сделает цикл аналогичным while (i < 3).
    // А можно и вообще убрать всё, получив бесконечный цикл:
    // for (;;) {
    //   // будет выполняться вечно
    // }
    // При этом сами точки с запятой ; обязательно должны присутствовать, иначе будет ошибка синтаксиса.

    // Прерывание цикла: «break»
    // Обычно цикл завершается при вычислении условия в false.
    // Но мы можем выйти из цикла в любой момент с помощью специальной директивы break.
    // Например, следующий код подсчитывает сумму вводимых чисел до тех пор, пока посетитель их вводит, а затем – выдаёт:
    // let sum = 0;
    // while (true) {
    //   let value = +prompt("Введите число", '');
    //   if (!value) break; // (*)
    //   sum += value;
    // }
    // alert( 'Сумма: ' + sum );

    //   Переход к следующей итерации: continue
    // Директива continue – «облегчённая версия» break. 
    // При её выполнении цикл не прерывается, а переходит к следующей итерации (если условие все ещё равно true).
    // цикл ниже использует continue, чтобы выводить только нечётные значения:
    // for (let i = 0; i < 10; i++) {
    // // если true, пропустить оставшуюся часть тела цикла
    // if (i % 2 == 0) continue;
    // alert(i); // 1, затем 3, 5, 7, 9
    // }

    // Нельзя использовать break/continue справа от оператора „?“
    // (i > 5) ? alert(i) : continue; // continue здесь приведёт к ошибке
    // …то будет синтаксическая ошибка.
    // Это ещё один повод не использовать оператор вопросительного знака ? вместо if.

    // Метки для break/continue
    // Бывает, нужно выйти одновременно из нескольких уровней цикла сразу.
    // Метка имеет вид идентификатора с двоеточием перед циклом:
    // labelName: for (...) {
    //   ...
    // }
    // Вызов break <labelName> в цикле ниже ищет ближайший внешний цикл с такой меткой и переходит в его конец.
    // outer: for (let i = 0; i < 3; i++) {
    //   for (let j = 0; j < 3; j++) {
    //     let input = prompt(`Значение на координатах (${i},${j})`, '');
    //     // если пустая строка или Отмена, то выйти из обоих циклов
    //     if (!input) break outer; // (*)
    //     // сделать что-нибудь со значениями...
    //   }
    // }
    // alert('Готово!');
    // В примере выше это означает, что вызовом break outer будет разорван внешний цикл
    // до метки с именем outer, и управление перейдёт со строки, помеченной (*), к alert('Готово!').

    // Задачи
    // Последнее значение цикла
    // Какое последнее значение выведет этот код? Почему?
    // let i = 3;
    // while (i) {
    //   alert( i-- );
    // }
    // Ответ: 1, потому что i уменьшается и 0 это false, значит выйдит из цикла и не успеет вывести 0

    // Какие значения выведет цикл while?
    // Для каждого цикла запишите, какие значения он выведет. Потом сравните с ответом.
    // Оба цикла выводят alert с одинаковыми значениями или нет? (разные)
    // Префиксный вариант ++i:
    // let i = 0;
    // while (++i < 5) alert( i ); // Ответ: 1,2,3,4
    // Постфиксный вариант i++
    // let i = 0;
    // while (i++ < 5) alert( i ); // Ответ: 1,2,3,4,5

    // Какие значения выведет цикл for?
    // Для каждого цикла запишите, какие значения он выведет. Потом сравните с ответом.
    // Оба цикла выведут alert с одинаковыми значениями или нет?
    // 1. Постфиксная форма:
    // for (let i = 0; i < 5; i++) alert( i );
    // 2. Префиксная форма:
    // for (let i = 0; i < 5; ++i) alert( i );
    // Ответ: от 0 до 4 в обоих случаях.
    // Такой результат обусловлен алгоритмом работы for:
    // Выполнить единожды присваивание i = 0 перед чем-либо (начало).
    // Проверить условие i < 5
    // Если true – выполнить тело цикла alert(i), и затем i++
    // Увеличение i++ выполняется отдельно от проверки условия (2), значение i при этом не используется,
    // поэтому нет никакой разницы между i++ и ++i.

    // Выведите чётные числа
    // При помощи цикла for выведите чётные числа от 2 до 10.
    // for (let i=2; i<=10; i++) {
    //     if (!(i%2)) {
    //         alert(i);
    //     }
    // }

    // Замените for на while
    // Перепишите код, заменив цикл for на while, без изменения поведения цикла.
    // for (let i = 0; i < 3; i++) {
    // alert( `number ${i}!` );
    // }
    // Ответ:
    // let i=0;
    // while (i<3) {
    //     alert( `number ${i}!` );
    //     i++;
    // }

    // Повторять цикл, пока ввод неверен
    // Напишите цикл, который предлагает prompt ввести число, большее 100.
    // Если посетитель ввёл другое число – попросить ввести ещё раз, и так далее.
    // Цикл должен спрашивать число пока либо посетитель не введёт число, большее 100, либо не нажмёт кнопку Отмена (ESC).
    // Предполагается, что посетитель вводит только числа.
    // Предусматривать обработку нечисловых строк в этой задаче необязательно.
    // let num;
    // do {
    // num = Number(prompt("Введите число, большее 100?", 0));
    // } while (num <= 100 && num);

    // Вывести простые числа
    // Натуральное число, большее 1, называется простым, если оно ни на что не делится, кроме себя и 1.
    // Другими словами, n > 1 – простое, если при его делении на любое число кроме 1 и n есть остаток.
    // Например, 5 это простое число, оно не может быть разделено без остатка на 2, 3 и 4.
    // Напишите код, который выводит все простые числа из интервала от 2 до n.
    // Для n = 10 результат должен быть 2,3,5,7.
    // P.S. Код также должен легко модифицироваться для любых других интервалов.
    // let interval = Number(prompt('Введите интервал',2));
    // nextPrime:
    // for (let i = 2; i <= interval; i++) { // Для всех i...
    //     for (let j = 2; j < i; j++) { // проверить, делится ли число..
    //         if (i % j == 0) continue nextPrime; // не подходит, берём следующее
    //     }
    //     alert( i ); // простое число
    // }
    </script>
</body>
</html>