<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>14.Функции</title>
</head>
<body>
    <script>
    // Функции
    // Объявление функции
    // function имя(параметры) {
    // ...тело...
    // }
    // Наша новая функция может быть вызвана по её имени: showMessage().
    // Например:
    // function showMessage() {
    // alert( 'Всем привет!' );
    // }
    // showMessage();
    // showMessage();
    
    // Локальные переменные
    // Переменные, объявленные внутри функции, видны только внутри этой функции.
    // Например:
    // function showMessage() {
    // let message = "Привет, я JavaScript!"; // локальная переменная
    // alert( message );
    // }
    // showMessage(); // Привет, я JavaScript!
    // alert( message ); // <-- будет ошибка, т.к. переменная видна только внутри функции

    // Внешние переменные
    // У функции есть доступ к внешним переменным, например:
    // let userName = 'Вася';
    // function showMessage() {
    // let message = 'Привет, ' + userName;
    // alert(message);
    // }
    // showMessage(); // Привет, Вася
    // Функция обладает полным доступом к внешним переменным и может изменять их значение.
    // Например:
    // let userName = 'Вася';
    // function showMessage() {
    // userName = "Петя"; // (1) изменяем значение внешней переменной
    // let message = 'Привет, ' + userName;
    // alert(message);
    // }
    // alert( userName ); // Вася перед вызовом функции
    // showMessage();
    // alert( userName ); // Петя, значение внешней переменной было изменено функцией

    // Параметры
    // Мы можем передать внутрь функции любую информацию, используя параметры (также называемые аргументами функции).
    // В нижеприведённом примере функции передаются два параметра: from и text.
    // function showMessage(from, text) { // аргументы: from, text
    // alert(from + ': ' + text);
    // }
    // showMessage('Аня', 'Привет!'); // Аня: Привет!
    // showMessage('Аня', "Как дела?"); // Аня: Как дела?

    // Параметры по умолчанию
    // Если параметр не указан, то его значением становится undefined.
    // Например, вышеупомянутая функция showMessage(from, text) может быть вызвана с одним аргументом:
    // showMessage("Аня");
    // Это не приведёт к ошибке. Такой вызов выведет "Аня: undefined". В вызове не указан параметр text,
    // поэтому предполагается, что text === undefined.
    // Если мы хотим задать параметру text значение по умолчанию, мы должны указать его после =:
    // function showMessage(from, text = "текст не добавлен") {
    // alert( from + ": " + text );
    // }
    // showMessage("Аня"); // Аня: текст не добавлен

    // Возврат значения
    // Функция может вернуть результат, который будет передан в вызвавший её код.
    // Простейшим примером может служить функция сложения двух чисел:
    // function sum(a, b) {
    // return a + b;
    // }
    // let result = sum(1, 2);
    // alert( result ); // 3
    // Возможно использовать return и без значения. Это приведёт к немедленному выходу из функции.
    // Например:
    // function showMovie(age) {
    // if ( !checkAge(age) ) {
    //     return;
    // }
    // alert( "Вам показывается кино" ); // (*)
    // // ...
    // }
    // В коде выше, если checkAge(age) вернёт false, showMovie не выполнит alert.
    // Если мы хотим, чтобы возвращаемое выражение занимало несколько строк, нужно
    // начать его на той же строке, что и return. Или, хотя бы, поставить там открывающую скобку, вот так:
    // return (
    // some + long + expression
    // + or +
    // whatever * f(a) + f(b)
    // )

    // Выбор имени функции
    // Функция – это действие. Поэтому имя функции обычно является глаголом.
    // Оно должно быть простым, точным и описывать действие функции, чтобы программист,
    // который будет читать код, получил верное представление о том, что делает функция.
    // Как правило, используются глагольные префиксы, обозначающие общий характер действия,
    // после которых следует уточнение. Обычно в командах разработчиков действуют соглашения,
    // касающиеся значений этих префиксов.
    // Например, функции, начинающиеся с "show" обычно что-то показывают.
    // Функции, начинающиеся с…
    // "get…" – возвращают значение,
    // "calc…" – что-то вычисляют,
    // "create…" – что-то создают,
    // "check…" – что-то проверяют и возвращают логическое значение, и т.д.
    // Примеры таких имён:
    // showMessage(..)     // показывает сообщение
    // getAge(..)          // возвращает возраст (в каком либо значении)
    // calcSum(..)         // вычисляет сумму и возвращает результат
    // createForm(..)      // создаёт форму (и обычно возвращает её)
    // checkPermission(..) // проверяет доступ, возвращая true/false
    // Благодаря префиксам, при первом взгляде на имя функции становится понятным что делает её код,
    // и какое значение она может возвращать.

    // Функции == Комментарии
    // Функции должны быть короткими и делать только что-то одно. Если это что-то большое, имеет
    // смысл разбить функцию на несколько меньших. Иногда следовать этому правилу непросто,
    // но это определённо хорошее правило.
    // Небольшие функции не только облегчают тестирование и отладку – само существование таких
    // функций выполняет роль хороших комментариев!
    // Например, сравним ниже две функции showPrimes(n). Каждая из них выводит простое число до n.
    // Первый вариант использует метку nextPrime:
    // function showPrimes(n) {
    // nextPrime: for (let i = 2; i < n; i++) {
    //     for (let j = 2; j < i; j++) {
    //     if (i % j == 0) continue nextPrime;
    //     }
    //     alert( i ); // простое
    // }
    // }
    // Второй вариант использует дополнительную функцию isPrime(n) для проверки на простое:
    // function showPrimes(n) {
    // for (let i = 2; i < n; i++) {
    //     if (!isPrime(i)) continue;
    //     alert(i);  // простое
    // }
    // }
    // function isPrime(n) {
    // for (let i = 2; i < n; i++) {
    //     if ( n % i == 0) return false;
    // }
    // return true;
    // }
    // Второй вариант легче для понимания, не правда ли? Вместо куска кода мы видим название
    // действия (isPrime). Иногда разработчики называют такой код самодокументируемым.
    // Таким образом, допустимо создавать функции, даже если мы не планируем повторно использовать их.
    // Такие функции структурируют код и делают его более понятным.

    // Задачи
    // Обязателен ли "else"?
    // Следующая функция возвращает true, если параметр age больше 18.
    // В ином случае она запрашивает подтверждение через confirm и возвращает его результат:
    // function checkAge(age) {
    // if (age > 18) {
    //     return true;
    // } else {
    //     // ...
    //     return confirm('Родители разрешили?');
    // }
    // }
    // Будет ли эта функция работать как-то иначе, если убрать else?
    // function checkAge(age) {
    // if (age > 18) {
    //     return true;
    // }
    // // ...
    // return confirm('Родители разрешили?');
    // }
    // Есть ли хоть одно отличие в поведении этого варианта?
    // Ответ: Оба варианта функций работают одинаково, отличий нет.

    // Перепишите функцию, используя оператор '?' или '||'
    // Следующая функция возвращает true, если параметр age больше 18.
    // В ином случае она задаёт вопрос confirm и возвращает его результат.
    // function checkAge(age) {
    // if (age > 18) {
    //     return true;
    // } else {
    //     return confirm('Родители разрешили?');
    // }
    // }
    // Перепишите функцию, чтобы она делала то же самое, но без if, в одну строку.
    // Сделайте два варианта функции checkAge:
    // Используя оператор ?:
    // function checkAge(age) {
    // (age > 18) ? true : confirm('Родители разрешили?'); // confirm - выбрасывает окно потверждения
    // }
    // Используя оператор ||:
    // function checkAge(age) {
    // return (age > 18) || confirm('Родители разрешили?');
    // }

    // Функция min(a, b)
    // Напишите функцию min(a,b), которая возвращает меньшее из чисел a и b.
    // Пример вызовов:
    // function min(num1,num2){
    //     (num1>num2) ? alert(num2) : alert(num1);
    // }
    // min(2, 5); // == 2
    // min(3, -1); // == -1
    // min(1, 1); // == 1

    // Функция pow(x,n)
    // Напишите функцию pow(x,n), которая возвращает x в степени n.
    // Иначе говоря, умножает x на себя n раз и возвращает результат.
    // pow(3, 2) = 3 * 3 = 9
    // pow(3, 3) = 3 * 3 * 3 = 27
    // pow(1, 100) = 1 * 1 * ...* 1 = 1
    // Создайте страницу, которая запрашивает x и n, а затем выводит результат pow(x,n).
    // P.S. В этой задаче функция обязана поддерживать только натуральные значения n, т.е. целые от 1 и выше.
    // let x=Number(prompt('Число которое нужно возвести в степень',0));
    // let n=Number(prompt('В какую степень возвести?',0));
    // function pow(x, n) {
    // let result = x;
    // for (let i = 1; i < n; i++) {
    //     result *= x;
    // }
    // return result;
    // }
    // let x = prompt("x?", '');
    // let n = prompt("n?", '');
    // if (n < 1) {
    // alert(`Степень ${n} не поддерживается, используйте натуральное число`);
    // } else {
    // alert( pow(x, n) );
    // }
    </script>
</body>
</html>